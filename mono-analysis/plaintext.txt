this paper describes a new basis for the implementation of the shifter functional unit in microprocessors that can implement new advanced bit manipulations as well as standard shifter operations. our design is based on the inverse butterfly and butterfly data path circuits, rather than the barrel shifter or log shifter designs currently used. we show how this new shifter can implement the standard shift and rotate operations, as well as more advanced extract, deposit, and mix operations found in some processors. furthermore, it can perform important new classes of even more advanced bit manipulation instructions like arbitrary bit permutations, bit gather, and bit scatter instructions. thus, our new functional unit performs the functionality of three functional units the basic shifter, the multimedia mix unit, and the advanced bit manipulation functional unit, while having latency only slightly longer than that of the log shifter. for performing only the existing functions of a shifter, it has significantly smaller area.

feedback control techniques have recently been applied to a variety of real time systems. however, a fundamental issue that was left out is guaranteeing system controllability and the feasibility of applying feedback control to such systems. no control algorithms can effectively control a system which itself is uncontrollable or infeasible. in this paper, we use the multiprocessor utilization control problem as a representative example to study the controllability and feasibility of distributed real time systems. we prove that controllability and feasibility of a system depend crucially on end to end task allocations. we then present algorithms for deploying end to end tasks to ensure that the system is controllable and utilization control is feasible for the system. furthermore, we develop runtime algorithms to maintain controllability and feasibility by reallocating tasks dynamically in response to workload variations, such as task terminations and migrations caused by processor failures. we implement our algorithms in a robust real time middleware system and report empirical results on an experimental test bed. we also evaluate the performance of our approach in large systems using numerical experiments. our results demonstrate that the proposed task allocation algorithms improve the robustness of feedback control in distributed real time systems.

real number calculations on elementary functions are remarkably difficult to handle in mechanical proofs. in this paper, we show how these calculations can be performed within a theorem prover or proof assistant in a convenient and highly automated as well as interactive way. first, we formally establish upper and lower bounds for elementary functions. then, based on these bounds, we develop a rational interval arithmetic where real number calculations take place in an algebraic setting. in order to reduce the dependency effect of interval arithmetic, we integrate two techniques: interval splitting and taylor series expansions. this pragmatic approach has been developed, and formally verified, in a theorem prover. the formal development also includes a set of customizable strategies to automate proofs involving explicit calculations over real numbers. our ultimate goal is to provide guaranteed proofs of numerical properties with minimal human theorem prover interaction.

reduced energy consumption is one of the most important design goals for embedded application domains like wireless communication, multimedia and biomedical applications. the instruction memory hierarchy has been proven to be one of the most power hungry parts of the system. this paper introduces an architectural enhancement for the instruction memory to reduce energy consumption and improve performance. the proposed distributed instruction memory organization requires minimal hardware overhead and supports the execution of multiple incompatible loops in parallel in a uniprocessor system. we present different methods to implement the loop controller architecture, compare them, and show that distributing the instruction memory helps to reduce the interconnect cost as well.
compared to higher precision data formats, lower precision data formats result in higher performance for computational intensive applications on fpgas because of their lower resource cost, reduced memory bandwidth requirements, and higher circuit frequency. on the other hand, scientific computations usually demand highly accurate solutions. this paper seeks to utilize lower precision data formats whenever possible for higher performance without losing the accuracy of higher precision data formats by using mixed precision algorithms and architectures. first, we analyze the floating point performance of different data formats on fpgas. second, we introduce mixed precision iterative refinement algorithms for linear solvers and give error analysis. finally, we propose an innovative architecture for a mixed precision direct solver for reconfigurable computing. our results show that our mixed precision algorithm and architecture significantly improve the performance of linear solvers on fpgas.

synchronous systems offer a clean semantics and an easy verification path at the expense of often inefficient implementations. capturing design specifications as synchronous models and then implementing the specifications in a less restrictive platform allow to address a much larger design space. the key issue in this approach is maintaining semantic equivalence between the synchronous model and its implementation. we address this problem by showing how to map a synchronous model onto a loosely time triggered architecture that is fairly straightforward to implement as it does not require global synchronization or blocking communication. we show how to maintain semantic equivalence between specification and implementation using an intermediate model that helps in defining the transformation. performance of the semantic preserving implementation is studied for the general case as well as for a few special cases.
